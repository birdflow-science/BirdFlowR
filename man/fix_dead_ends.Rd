% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_dead_ends.R, R/fix_dead_ends.R
\name{find_dead_ends}
\alias{find_dead_ends}
\alias{fix_dead_ends}
\title{find and fix inconsistencies in sparse BirdFlow models}
\usage{
find_dead_ends(x)

fix_dead_ends(bf, max_attempts = 100)
}
\arguments{
\item{x}{\code{BirdFlow} model}

\item{bf}{BirdFlow model}

\item{max_attempts}{The maximum number of iterations to try before giving up}
}
\value{
`find_dead_ends() returns a data.frame with columns:\tabular{ll}{
   \code{timestep} \tab the timestep associated with the dead end \cr
    \tab \cr \cr
   \code{direction} \tab either \code{"forward"} or \code{"backward"} indicating which direction the dead end is encountered in \cr
    \tab \cr \cr
   \code{i} \tab the index of the model state that has a dead end \cr
    \tab \cr \cr
   \code{mar} \tab the marginal which leads into the dead end (this marginal has non-zero value in the i'th column if direction is forward and i'th row if direction is backward) \cr
    \tab \cr \cr
   \code{x}, and \code{y} \tab the x and y coordinates corresponding with state \code{i} \cr
}


There will be a row for each dead end state, if no dead ends are found an
empty (zero row) data.frame is returned.

\code{fix_dead_ends()} returns a BirdFlow model with additional marginal
row and columns zeroed out. If successful it will have no dead ends. It
also adds a data.frame  \code{fix_stats} to \code{bf$metadata$sparse}.
}
\description{
With sparsification (\code{\link[=sparsify]{sparsify()}}) it's possible to create models that
have dead ends -  states that can be entered but not exited. This occurs when
one marginal encodes transitions into a state for which the next marginal
has no transitions out. These functions find and fix those states.
}
\details{
Consider two adjacent marginals; the rows of the second and the columns of
the first both correspond with the species distribution for the timestep
between them. For every location in the model at that timestep there are
four possibilities (1) the first marginal's column has non-zero values and
the second marginal's row is all zero: there is a forward transition into
that state but no forward transition out and it's a forward dead end; (2)
the situation is reversed and the first marginals column is all zeros and
the second marginal's corresponding row has non-zero values, a backward dead
end (encountered when projecting backwards in time); (3) if they both have
only zeros: the model is fine but that state is dropped; and (4) if they
both have non-zero values than the corresponding state is valid and can be
reached and exited when projecting forward or backwards.

Dead ends result in lost density with \code{\link[=forecast]{forecast()}} and errors when they are
entered with \code{\link[=route]{route()}}. Based on initial testing the transitions into the
dead end are often low probability so routing may work most of the time but
occasionally fail. The error will occur with the subsequent iteration when
attempting to sample from a bunch of zero probability states.
}
\examples{
library(BirdFlowModels)
bf <- amewoo
head(find_dead_ends(amewoo))

}
\seealso{
\code{\link[=sparsify]{sparsify()}} calls \code{fix_dead_ends()}, which in turn calls
\code{find_dead_ends()} and \code{\link[=fix_current_dead_ends]{fix_current_dead_ends()}}.
}
