% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess_species.R
\name{preprocess_species}
\alias{preprocess_species}
\title{prepare eBird Status and Trends data for BirdFlow model fitting}
\usage{
preprocess_species(
  species = NULL,
  out_dir = NULL,
  res = NULL,
  hdf5 = TRUE,
  overwrite = TRUE,
  crs = NULL,
  clip = NULL,
  max_params = NULL,
  gpu_ram = 12,
  skip_quality_checks = FALSE,
  ...
)
}
\arguments{
\item{species}{a species in any format accepted by \code{\link[ebirdst:get_species]{ebirdst::get_species()}}}

\item{out_dir}{output directory, files will be written here. Required unless
\code{hdf5} is FALSE.  File names created here will incorporate
the species code, resolution, and eBird version year.}

\item{res}{the target resolution of the BirdFlow model in kilometers. If
\code{res} is NULL (default) then a resolution that results in less than \code{max_params}
parameters will be used, while also minimizing the resolution and limiting
the number of significant digits.}

\item{hdf5}{if TRUE (default) an hdf5 file will be exported.}

\item{overwrite}{if TRUE (default) any pre-existing output files will be
overwritten. If FALSE pre-existing files will result in an error.}

\item{crs}{coordinate reference system (CRS) to use.  Defaults to the custom
projection eBird has assigned to this species - see
\code{\link[ebirdst:load_fac_map_parameters]{ebirdst::load_fac_map_parameters()}}). It will be interpreted by
\code{\link[terra:crs]{terra::crs()}} to generate a well known text representation of the CRS.}

\item{clip}{a polygon or the path to a file containing a polygon. It must
have a CRS and should either be a \link[terra:SpatVector-class]{SpatVector()} object
or produce one when called with \link[terra:vect]{vect(clip)}}

\item{max_params}{the maximum number of fitted parameters that the BirdFlow
model should contain. Ignored if \code{res} is not NULL.  Otherwise a resolution
will be chosen that yields this many fitted parameters. See \code{gpu_ram} for
the default way of setting \code{max_params} and \code{res}. Note: the reduction in
paramters resulting from truncation (see \code{...}) is not factored into the
calculation.}

\item{gpu_ram}{Gigabytes of ram on GPU machine that will fit the models.
If \code{res} is NULL and \code{max_params} is NULL this is used to estimate
\code{max_params}which is, in turn, used to determine the resolution. Ignored
if either\code{ res} or \code{max_params} is set.}

\item{skip_quality_checks}{If \code{TRUE} than preprocess the species even if
not all of four ranges are modeled (based on
\link[ebirdst:ebirdst_runs]{ebirdst_runs()}).}

\item{...}{
  Arguments passed on to \code{\link[=lookup_timestep_sequence]{lookup_timestep_sequence}}
  \describe{
    \item{\code{season}}{a season name, season alias, or "all".  See
\code{\link[=lookup_season_timesteps]{lookup_season_timesteps()}} for options.}
    \item{\code{start}}{The starting point in time specified as a
timestep, character date, or date object.}
    \item{\code{end}}{The ending point in time as a date or timestep.}
    \item{\code{direction}}{Either "forward" or "backward" defaults to
\code{"forward"} if not processing dates.  If using date input \code{direction} is
optional and is only used to verify the direction implicit in the dates.}
    \item{\code{season_buffer}}{Only used with \code{season} input. \code{season_buffer} is
passed to \code{\link[=lookup_season_timesteps]{lookup_season_timesteps()}} and defaults to 1; it is the number
of timesteps to extend the season by at each end.}
    \item{\code{n_steps}}{Alternative to \code{end}  The end will be \code{n_steps} away from
\code{start} in \code{direction}; and the resulting sequence will have \code{n_step}
transitions and \code{n_steps + 1}  timesteps.}
  }}
}
\value{
returns a BirdFlow model object that lacks marginals, but is
otherwise complete.  It is suitable for fitting with
\href{https://github.com/birdflow-science/BirdFlowPy}{BirdFlowPy}.
}
\description{
Write a template BirdFlow object to an hdf5 file based on distribution data
downloaded with \pkg{ebirdst}. The object is complete except for marginals
and transitions.  Use \code{...} to truncate the model to part of the year.
}
\section{{Maximum number of parameters}}{


The maximum number of parameters that can be fit is machine dependent.
2023-02-10 we tested under different resolutions with "amewoo" and
identified bounds on the maximum.\tabular{lllll}{
   Machine \tab GPU Ram (GB) \tab Lower Bound (worked) \tab Upper Bound (failed) \tab Params / GB \cr
   titanx gpu \tab 12GB \tab 306804561 \tab 334693725 \tab 25567047 \cr
   m40 gpu \tab 24GB \tab 557395226 \tab 610352178 \tab 23224801 \cr
}


The number of parameters is the number of unmasked cells for the first
timestep + the total number of cells in the marginals which is calculated
from the dynamic mask.

If \code{gpu_ram} is used (and not \code{res} or \code{max_parameters} ) than
\code{max_parameters} is set to \verb{23,224,801 * gpu_ram} (lower of two values in
table above).

The heuristic to determine resolution given a maximum number of parameters
must estimate the number of cells covered by the data
at a different resolution, a noisy process, so it iteratively tries to find
the smallest resolution that doesn't exceed \code{max_params} and then rounds to
a slightly larger resolution (fewer parameters).
}

\examples{
\dontrun{

 bf <- preprocess_species("amewoo", tiff = FALSE, hdf5 = FALSE )
 plot(rasterize_distr(get_distr( bf, c(1, 26)), bf))

# Create clip polgyon as an sf object
# Use the extent rectangle but with western edge moved in
# The clip can be anything that terra::vect will process into a polygon
e <- ext(bf)
e[1] <- -1500000
coords <- matrix(c(e[1], e[3],
                   e[1], e[4],
                   e[2], e[4],
                   e[2], e[3],
                   e[1], e[3]), ncol = 2, byrow = TRUE)
sfc <- st_sfc(st_polygon(list(coords)), crs = crs(bf))
clip <- st_sf(data.frame(id = 1, geom = sfc))

bfc <- preprocess_species("amewoo", tiff = FALSE,
                         hdf5 = FALSE, clip = clip ) # clipped bird flow

 plot(rasterize_distr(get_distr(bfc, 1), bfc))


}
}
